# Custom Actions

Frame.io Actions allow integrations with 3rd party tools and services to be surfaced directly within the user interface of [Frame.io](https://next.frame.io/). Custom Actions allow developers to create, manage and host their own Actions. Leveraging the same underlying Event system as [Webhooks](https://developer.adobe.com/frameio/guides/Webhooks/), custom Actions are an alternative mechanism developers can use to connect their Assets to the tools that matter most to users in their Frame.io Account.

Actions can be executed by any user within the Frame.io account via the context menu presented when right-clicking on an asset. When executing an Action, Frame.io sends a payload to a URL you provide. The receiving application responds with an HTTP status code to acknowledge receipt, or responds with a custom callback to can render additional UI in Frame.io. The recieving application can be your own hosted program or service, or even low-code/no-code IPaaS tool like Workfront Fusion or Zapier.  

Custom Actions can be created and managed via [endpoints made available in the Frame.io V4 Developer API](/frameio/api/experimental/#tag/Custom-Actions), or via a new [Actions settings page (beta)](https://next.frame.io/settings/actions) available in the Frame.io V4 web app. Any user can see Actions in Settings (and List via the API) but only Content Admins and Account Owners can Create, Edit, Delete or Update Actions.

## Anatomy of an Action
<br/>

|Field name	|Description	|
|---	|---	|
|Name	|The name you choose for your Action. It will be used in the context menu in Frame.io	|
|Description	|Explains what the Action does for users reference. It will be displayed under the Action's Name in the context menu	|
|Event	| An internal Event key to help you differentiate between Frameio system Events and your own	|
|URL	|Where to deliver Events, either your self-hosted application or an IPaSS tool	|
|Workspace	|The Workspace your Action will be made available in	|

## Payload From Frame.io

When your Action is executed, a payload is sent to the URL set in the Action's configuration. Use this payload to identify:

* Which Action was executed
* Which Account is associated with the Action
* Which Project contains the asset the Action was executed on
* Which Resource the Action was executed on and it's type
* Which Event was executed
* Which User executed the Action
* Which Workspace is associated with the Action


```json
POST /your/url
{
    "account_id": "9a44f696-ae69-4e0c-9731-806d27ea46f1",
    "action_id": "ecd40785-4485-4f07-9d26-a006ea84efdf",
    "interaction_id": "e0a1c945-a8da-480d-92fb-e895cb640a01",
    "project":
    {
        "id": "3dda6833-ec3b-46bd-a7d9-1a77c03a165b"
    },
    "resource":
    {
        "id": "f9d5728c-ac1a-4f48-92bb-ea2f9be3c58b",
        "type": "file"
    },
    "type": "two.event",
    "user":
    {
        "id": "50d976e6-27d2-47cb-9388-45b38d55f4f0"
    },
    "workspace":
    {
        "id": "382a1fe6-67cf-481e-9b65-79cfd9e9727f"
    }
}
```

| Field name     | Description     |
| ---------- | ---------- |
| `account_id`       | The unique Account identifier this Action belongs to. It is always be the same for a given Action.|
| `action_id`       | The unique identifier of the Action itself. It is always the same for a given Action.|
| `interaction_id`       | Unique identifier generated by Frame.io that you can use to keep track of your Action's transcations over time. This identifier is the same throughout the sequence of a given Action's execution, including callback forms.|
| `project_id`       | Unique identifier of the Project conataining the Asset this Action was triggered on. |
| `resource.id`       | The id of the resource your Action was executed on (usually an Asset). |
| `resource.type`       | The type of resource your Action was executed on. Possible values include `file`,`folder` or `version_stack`. |
| `type`       | The internal Event key defined when configuring your Action. |
| `user.id`       | The unique identifier of the User who executed the Action. |
| `workspace.id`       | The unique identifier of the Workspace the Action belongs to. It is always the same for a given Action. |
| `data`| Object containing key-value pairs denoting the name of each form element and the value selected. |

## Interactions, Retries and Timeouts

The `interaction_id` is a unique identifier to track of the interaction as it evolves over time. If you do not need to respond to the user, return a 200 status code, and you're done. While optional, we recommend including information about the result of the action, like a success message or error alert. Custom actions support message callbacks.Frame.io expects a response in less than 10 seconds, and attempts to retry up to 5 times while waiting for a successful response. Ideally the response is immediate and asynchronous actions occur after a trigger via a Custom Action.

## Create a Message Callback

In your HTTP response to the webhook event, you can return a JSON object describing a message that will be returned to the initiating user in the Frame.io UI.

```json
{
  "title": "Success!",
  "description": "The thing worked! Nice."
}
```

Messages close the action loop providing variable context to the user, without asking them to switch contexts. When the initial payload and subsequent calls to the Frame.io API don't provide enough context for the receiving application, use **Form Callbacks**.

## Create a Form Callback

Let's say that you need more info before you start your process. For example, you may be uploading content to a system that requires additional details and settings. You can describe a Form in your response, which the user sees snd fills out, and is then sent right back to you! Here's an example form that renders a Form in the Frame.io UI that the acting user can fill out and submit:

```json
{
  "title": "Need some more info!",
  "description": "Getting ready to submit this file!",
  "fields": [
    {
      "type": "text",
      "label": "Title",
      "name": "title",
      "value": "MyVideo.mp4"
    },
    {
      "type": "select",
      "label": "Captions",
      "name": "captions",
      "options": [
        {
          "name": "Off",
          "value": "off"
        },
        {
          "name": "On",
          "value": "on"
        }
      ]
    }
  ]
}
```

When the user submits the form, you'll receive an event on the same URL as the initial POST:

```json
POST /your/url
{
  "type": "your-specified-event-name",
  "interaction_id": "the-same-id-as-before",
  "action_id": "unique-id-for-this-custom-action",
  "data":{
    "title": "MyVideo.mp4",
    "captions": "off"
  }
}
```

All custom fields added on a form appear in the data section of the JSON payload sent by Frame.io. Use the `interaction_id` to map the initial request and this new form data. And again, you can respond with a message (or even another form!). By chaining Actions, Forms, and Messages, you can effectively program entire Asset workflows in Frame.io with business logic from an external system.

## Form Details

Like messages, Forms support `title` and `description` attributes that render at the top of the Form. Beyond that, each form field accepts the following base attributes:

* type -- Tells the Frame.io UI which type of data to expect, and which component and render.
* label -- Appears on the UI as the header above the field.
* name -- Key by which the field will be identified on the subsequent payload.
* value -- Value with which to pre-populate the field.

## Supported Field Types

### Text Field

A simple text field with no additional parameters.

```json
{  
  "type": "text",
  "label": "Title",
  "name": "title",
  "value": "MyVideo.mp4"
}
```

### Text Area

A simple text area with no additional parameters.

```json
{  
  "type": "textarea",
  "label": "Description",
  "name": "description",
  "value": "This video is really, really popular."
}
````

### Select List

Defines a picklist that the user can choose from. Must include an `options` list, each member of which should include a human-readable `name`, and a machine-parseable `value`.

```json
{
  "type": "select",
  "label": "Captions",
  "name": "captions",
  "value": "off",
  "options": [
       {
         "name": "Off",
         "value": "off"
       },
       {
         "name": "On",
         "value": "on"
      }
   ]
}
```

### Checkbox

A simple checkbox with no additional parameters.

```json
{ 
   "type": "boolean", 
   "name": "enabled", 
   "label": "Enabled", 
   "value": "false"
}
```

### Link

A simple link with no additional parameters.

```json
  {
    "type": "link",
    "name": "videoLink",
    "label": "Video Link",
    "value": "https://www.youtube.com/watch?v=XtX1zv9CEVc"
 }
 ```

## The Frame.io Permissions Model

Custom Actions have a special permissions model: they belong to a Workspace, not to any specific user who exists on an Account. That means:

* Any Content Admin can create a Custom Action on a Workspace.
* Any Content Admin can modify or delete a Custom Action that exists on a Team.  Once modified, all users will immediately see the result of the change.

## Security and Verification

By default, all Custom Actions have a signing key generated during their creation. This is not configurable. This key can be used to verify that the request originates from Frame.io. Included in the `POST` request are the following:

| Name     | Description     |
| ---------- | ---------- |
| `X-Frameio-Request-Timestamp`       | The time your Custom Action was triggered.       |
| `X-Frameio-Signature`       | The computed signature.       |

* **The timestamp** is the time the request was signed on its way out of Frame.io's network. This can be used to prevent replay attacks. We recommended verifying this time is within 5 minutes of local time.
* **The signature** is a HMAC SHA-256 hash using the signing key provided when the Custom Action is first created.

### Verifying the Signature

1. Extract the signature from the HTTP headers.
2. Create a message to sign by combining the version, delivery time, and request body `v0:timestamp:body`.
3. Compute the HMAC SHA256 signature using your signing secret.

**Note**: The provided signature is prefixed with `v0=`. Currently Frame.io only has this one version for signing requests. You will need to add this prefix to your computed signature.

Compare!

```python
import hmac
import hashlib
**def** verify_signature(curr_time, req_time, signature, body, secret):
    """
    Verify webhook/custom action signature
    :Args:
        curr_time (float): Current epoch time
        req_time (float): Request epoch time
        signature (str): Signature provided by the frame.io API for the given request
        body (str): Custom Action body from the received POST
        secret (str): The secret for this Custom Action that you saved when you first created it
    """
    if int(curr_time) - int(req_time) < 500:
        message = 'v0:{}:{}'.format(req_time, body)
        calculated_signature = 'v0={}'.format(hmac.new(
            bytes(secret, 'latin-1'),
            msg=bytes(message, 'latin-1'),
            digestmod=hashlib.sha256).hexdigest())
        if calculated_signature == signature:
            return True
    return False
```
